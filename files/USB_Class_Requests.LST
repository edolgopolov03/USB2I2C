C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE USB_CLASS_REQUESTS
OBJECT MODULE PLACED IN USB_Class_Requests.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe USB_Class_Requests.c DB OE CD INCDIR(c:\SiLabs\MCU\Inc) COMPACT

line level    source

   1          //-----------------------------------------------------------------------------
   2          // USB_Class_Requests.c
   3          //-----------------------------------------------------------------------------
   4          //
   5          //      Handler for class specific request and Vendor request
   6          
   7          //-----------------------------------------------------------------------------
   8          // Includes
   9          //-----------------------------------------------------------------------------
  10          
  11          #include "USB_CDC_Type.h"
  12          #include "USB_Register.h"
  13          #include "USB_Descriptor.h"
  14          #include "USB_Standard_Requests.h"
  15          #include "USB_CDC_UART.h"
  16          #include "FIFO_RW.h"
  17          
  18          //-----------------------------------------------------------------------------
  19          // Constant
  20          //-----------------------------------------------------------------------------
  21          
  22          // CDC ACM vendor specifc requests
  23          #define VR_FLOW_CONTROL         0x01    // flow control
  24          
  25          //-----------------------------------------------------------------------------
  26          // Externs
  27          //-----------------------------------------------------------------------------
  28          
  29          extern Tsetup_buffer Setup;                             // Buffer for current device request
  30          extern bit   setup_handled;                             // flag that indicates setup stage is handled or not
  31          extern UINT  DataSize;
  32          extern BYTE* DataPtr;
  33          
  34          extern BYTE USB_State;                                  // Holds the current USB State
  35                                                                                          // def. in USB_Main.h
  36          extern BYTE Ep_Status0;
  37          extern bit Ep_Status1;                                  // Contains status bytes for EP 0-2
  38          extern bit Ep_StatusOUT2;
  39          extern bit Ep_StatusIN2;
  40          
  41          extern Ttxbuffer TXBuffer[ TXBUFSIZE ]; // Ring buffer for TX and RX
  42          extern Trxbuffer RXBuffer[ RXBUFSIZE ];
  43          extern Ttxbuffer * TXWTPtr;
  44          extern Trxbuffer * RXRDPtr;
  45          
  46          //-----------------------------------------------------------------------------
  47          // Global Variables
  48          //-----------------------------------------------------------------------------
  49          
  50          BYTE cs_Line_State = 0;                                 // serial line state
  51          bit cs_Line_State_Update = FALSE;               // update line state
  52          
  53          #define CS_TEMPBUF_SIZE         sizeof(TLine_Coding)    // size of temporary buffer
  54                                                                                          // must be greater than sizeof(TLine_Coding) (= 7 bytes)
  55          BYTE idata cs_temp_buffer[ CS_TEMPBUF_SIZE ];   // temporary buffer for
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 2   

  56                                                                                                          //  CS_Get_Encapsulated_Command
  57                                                                                                          //  CS_Send_Encapsulated_Command
  58                                                                                                          //  CS_Set_Line_Coding and CS_Get_Line_Coding
  59          
  60          //-----------------------------------------------------------------------------
  61          // Function prototypes
  62          //-----------------------------------------------------------------------------
  63          
  64          void CS_Send_Encapsulated_Command(void);
  65          void CS_Get_Encapsulated_Command(void);
  66          void CS_Set_Line_Coding(void);
  67          void CS_Get_Line_Coding(void);
  68          void CS_Set_ControlLine_State(void);
  69          void CS_Send_Break(void);
  70          
  71          #if defined BIG_ENDIAN
  72          
  73          void swap_endian_long( ULONG idata *lptr );
  74          
  75          #endif // end of BIG_ENDIAN
  76          
  77          //-----------------------------------------------------------------------------
  78          // SDCC suport
  79          //-----------------------------------------------------------------------------
  80          #if defined SDCC
              #pragma save
              #pragma nooverlay
              #endif // SDCC
  84          
  85          //-----------------------------------------------------------------------------
  86          // class specific request handler
  87          //-----------------------------------------------------------------------------
  88          
  89          void Class_Request( void )
  90          {
  91   1              if ( Setup.wIndex.i == 0 )              // interface index must be 0 - Comm Class IF
  92   1              {
  93   2                      switch(Setup.bRequest)          // dispatch according to the request
  94   2                      {
  95   3                              case SEND_ENCAPSULATED_COMMAND:         CS_Send_Encapsulated_Command(); break;
  96   3                              case GET_ENCAPSULATED_RESPONSE:         CS_Get_Encapsulated_Command();  break;
  97   3                              case SET_LINE_CODING:                           CS_Set_Line_Coding();                   break;
  98   3                              case GET_LINE_CODING:                           CS_Get_Line_Coding();                   break;
  99   3                              case SET_CONTROL_LINE_STATE:            CS_Set_ControlLine_State();             break;
 100   3                              case SEND_BREAK:                                        CS_Send_Break();                                break;
 101   3                              default:                                                                                                                        break;
 102   3                      }
 103   2              }
 104   1      }
 105          
 106          //-----------------------------------------------------------------------------
 107          // Support Subroutines
 108          //-----------------------------------------------------------------------------
 109          
 110          //-----------------------------------------------------------------------------
 111          // Send_Encapsulated_Command
 112          //-----------------------------------------------------------------------------
 113          //
 114          //      Nothing to do other than unloading the data sent in the data stage.
 115          //
 116          //-----------------------------------------------------------------------------
 117          
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 3   

 118          void CS_Send_Encapsulated_Command(void)
 119          {
 120   1              if (   (Setup.bmRequestType == OUT_CL_INTERFACE)
 121   1                      && (Setup.wValue.i == 0 )
 122   1                      && (Setup.wLength.i <= CS_TEMPBUF_SIZE) )       // less than the buffer size
 123   1              {
 124   2                      Ep_Status0 = EP_RX;                             // Put endpoint in recieve mode
 125   2                      DataPtr = (BYTE *)cs_temp_buffer;
 126   2                      DataSize = Setup.wLength.i;             // Read out the command sent
 127   2                      setup_handled = TRUE;
 128   2              }
 129   1      }
 130          
 131          //-----------------------------------------------------------------------------
 132          // Get_Encapsulated_Command
 133          //-----------------------------------------------------------------------------
 134          //
 135          //      Return a zero-length packet
 136          //
 137          //-----------------------------------------------------------------------------
 138          
 139          void CS_Get_Encapsulated_Command(void)
 140          {
 141   1              if (   (Setup.bmRequestType == IN_CL_INTERFACE)
 142   1                      && (Setup.wValue.i == 0) )
 143   1              {
 144   2                      Ep_Status0 = EP_TX;                             // Put endpoint in transmit mode
 145   2                      DataPtr = (BYTE *)cs_temp_buffer;
 146   2                      DataSize = 0;                                   // Send ZLP
 147   2                      setup_handled = TRUE;
 148   2              }
 149   1      }
 150          
 151          //-----------------------------------------------------------------------------
 152          // Set_Line_Coding
 153          //-----------------------------------------------------------------------------
 154          //
 155          //      Unload the line coding structure (7 bytes) sent in the data stage.
 156          //      Apply this setting to the UART
 157          //      Flush the communication buffer
 158          //
 159          //      Line Coding Structure (7 bytes)
 160          //      0-3 dwDTERate    Data terminal rate (baudrate), in bits per second (LSB first)
 161          //      4   bCharFormat  Stop bits: 0 - 1 Stop bit, 1 - 1.5 Stop bits, 2 - 2 Stop bits
 162          //      5   bParityType  Parity:    0 - None, 1 - Odd, 2 - Even, 3 - Mark, 4 - Space
 163          //      6   bDataBits    Data bits: 5, 6, 7, 8, 16
 164          //
 165          //-----------------------------------------------------------------------------
 166          
 167          void CS_Set_Line_Coding(void)
 168          {
 169   1              if (   (Setup.bmRequestType == OUT_CL_INTERFACE)
 170   1                      && (Setup.wValue.i == 0)
 171   1                      && (Setup.wLength.i == sizeof(TLine_Coding)) )
 172   1              {
 173   2                      Ep_Status0 = EP_RX;                                             // Put endpoint in recieve mode
 174   2                      DataPtr = (BYTE *)cs_temp_buffer;
 175   2                      DataSize = sizeof(TLine_Coding);                // Read out the command sent
 176   2                      setup_handled = TRUE;
 177   2              }
 178   1      }
 179          
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 4   

 180          // called at the end of data stage
 181          void CS_Set_Line_Coding_Complete(void)
 182          {
 183   1      
 184   1      #if defined BIG_ENDIAN
 185   1                                                      // swap baudrate field LSB first --> MSB first
 186   1              swap_endian_long( (ULONG idata *)cs_temp_buffer );
 187   1      
 188   1      #endif // end of BIG_ENDIAN
 189   1      
 190   1              Set_Line_Coding( (TLine_Coding idata *)cs_temp_buffer );
 191   1      }
 192          
 193          //-----------------------------------------------------------------------------
 194          // Get_Line_Coding
 195          //-----------------------------------------------------------------------------
 196          //
 197          //      Return the line coding structure
 198          //
 199          //-----------------------------------------------------------------------------
 200          
 201          void CS_Get_Line_Coding(void)
 202          {
 203   1              if (   (Setup.bmRequestType == IN_CL_INTERFACE)
 204   1                      && (Setup.wValue.i == 0)
 205   1                      && (Setup.wLength.i == sizeof(TLine_Coding)) )
 206   1              {
 207   2      
 208   2      #if defined BIG_ENDIAN
 209   2                      BYTE cnt;
 210   2                      BYTE idata * dst;
 211   2                      BYTE idata * src;
 212   2      
 213   2                      dst = cs_temp_buffer;                   // copy line coding structure
 214   2                      src = (BYTE idata *)&uart_line_coding;
 215   2                      for (cnt = sizeof( TLine_Coding ); cnt > 0; cnt--)
 216   2                              *dst++ = *src++;
 217   2      
 218   2                      swap_endian_long( (ULONG idata *)cs_temp_buffer );
 219   2      
 220   2                      DataPtr = (BYTE *)cs_temp_buffer;
 221   2      #else
                              DataPtr = (BYTE *)(&uart_line_coding);  // send it directly
              #endif // end of BIG_ENDIAN
 224   2      
 225   2                      Ep_Status0 = EP_TX;                                     // Put endpoint in transmit mode
 226   2                      DataSize = sizeof(TLine_Coding);        // Send Line coding
 227   2                      setup_handled = TRUE;
 228   2              }
 229   1      }
 230          
 231          //-----------------------------------------------------------------------------
 232          // Set_ControlLine_State
 233          //-----------------------------------------------------------------------------
 234          //
 235          //      Set/reset RTS/DTR according to wValue
 236          //      wValue
 237          //       bit 1  RTS
 238          //       bit 0  DTR
 239          //
 240          //-----------------------------------------------------------------------------
 241          
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 5   

 242          void CS_Set_ControlLine_State(void)
 243          {
 244   1              if (   (Setup.bmRequestType == OUT_CL_INTERFACE)
 245   1                      && (Setup.wLength.i == 0) )
 246   1              {
 247   2                      Set_Line_State( Setup.wValue.c[LSB] & (CDC_RTS | CDC_DTR ) );
 248   2                      setup_handled = TRUE;
 249   2              }
 250   1      }
 251          
 252          //-----------------------------------------------------------------------------
 253          // Send_Break
 254          //-----------------------------------------------------------------------------
 255          //
 256          //      Send break from UART TX port, for wValue (msec) duration.
 257          //      wValue
 258          //       0xFFFF: continuous break
 259          //       0x0000: stop break
 260          //
 261          //-----------------------------------------------------------------------------
 262          
 263          void CS_Send_Break(void)
 264          {
 265   1              if (   (Setup.bmRequestType == OUT_CL_INTERFACE)
 266   1                      && (Setup.wLength.i == 0) )
 267   1              {
 268   2                      Send_Break( Setup.wValue.i );
 269   2                      setup_handled = TRUE;
 270   2              }
 271   1      }
 272          
 273          //-----------------------------------------------------------------------------
 274          // Vendor request handler
 275          //-----------------------------------------------------------------------------
 276          //  Flow control
 277          //    Vendor OUT requrest
 278          //    0x41    bmRequestType (OUT, Vendor, Interface)
 279          //    0x01    bRequest      (Flow control request)
 280          //    xxxx    wValue        (Flow control code)
 281          //    0x0000  wIndex        (Interface #)
 282          //    0x0000  wLength
 283          //
 284          //    Vendor IN requrest
 285          //    0xC1    bmRequestType (IN, Vendor, Interface)
 286          //    0x01    bRequest      (Flow control request)
 287          //    0x0000  wValue
 288          //    0x0000  wIndex        (Interface #)
 289          //    0x0002  wLength
 290          //
 291          //    Flow control code
 292          //    0x01  RTS-CTS
 293          //    0x02  DTR-DSR
 294          //-----------------------------------------------------------------------------
 295          
 296          // comment out temporarily              
 297          void Vendor_Request( void )
 298          {
 299   1      }
 300          
 301          /*
 302          BYTE cs_flow_control;
 303          
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 6   

 304          void Vendor_Request( void )
 305          {
 306                  if (   (Setup.bRequest == VR_FLOW_CONTROL)
 307                          && (Setup.wIndex.i == 0) )
 308                  {
 309                          switch ( Setup.bmRequestType )
 310                          {
 311                                  case OUT_VR_INTERFACE:
 312                                          if ( Setup.wLength.i == 0 )
 313                                          {
 314                                                  cs_flow_control = Setup.wValue.i;
 315                                                  // call flow control setup routine here
 316                                                  setup_handled = TRUE;
 317                                          }
 318                                          break;
 319                                  case IN_VR_INTERFACE:
 320                                          if (   (Setup.wValue.i == 0)
 321                                                  && (Setup.wLength.i == 1) )
 322                                          {
 323                                                  Ep_Status0 = EP_TX;
 324                                                  DataPtr = (BYTE *)&cs_flow_control;
 325                                                  DataSize = 1;
 326                                                  setup_handled = TRUE;
 327                                          }
 328                                          break;
 329                                  default:
 330                                          break;
 331                          }
 332                  }
 333          }
 334          */
 335          
 336          //-----------------------------------------------------------------------------
 337          // Handle_In1
 338          //-----------------------------------------------------------------------------
 339          //
 340          // Interrupt IN EP - Notification element
 341          //      Return SerialState notification response (10 bytes) to host 
 342          //      whenever the status are changed
 343          //
 344          //      response
 345          //    0:  0xA1   bmRequestType
 346          //    1:  0x20   bNotification (SERIAL_STATE)
 347          //    2:  0x00   wValue
 348          //    3:  0x00
 349          //    4:  0x00   wIndex (Interface #, LSB first)
 350          //    5:  0x00
 351          //    6:  0x02   wLength (Data length = 2 bytes, LSB first)
 352          //    7:  0x00
 353          //    8:  xx     UART State Bitmap (16bits, LSB first)
 354          //    9:  xx
 355          //
 356          //  UART State Bitmap
 357          //    15-8: reserved
 358          //    7:  (no spec extra) CTS
 359          //    6:  bOverRun    overrun error
 360          //    5:  bParity     parity error
 361          //    4:  bFraming    framing error
 362          //    3:  bRingSignal RI
 363          //    2:  bBreak      break reception
 364          //    1:  bTxCarrier  DSR
 365          //    0:  bRxCarrier  DCD
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 7   

 366          //
 367          //-----------------------------------------------------------------------------
 368          
 369          #define CS_SERIAL_STATE_NUM             0x08
 370          
 371          BYTE code serialStateResponse[ CS_SERIAL_STATE_NUM ] = 
 372          {
 373                  0xA1, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00
 374          };
 375          
 376          void Handle_In1( void )
 377          {
 378   1              BYTE ControlReg;
 379   1      
 380   1              if (Ep_Status1 == EP_IDLE)
 381   1              {
 382   2                      POLL_WRITE_BYTE(INDEX, 1);                                              // Set index to endpoint 1 registers
 383   2                      POLL_READ_BYTE(EINCSR1, ControlReg);                    // Read contol register for EP
 384   2      
 385   2                      if ( !(ControlReg & rbInINPRDY)                                 // FIFO is empty?
 386   2                              && cs_Line_State_Update )                                       // and must update?
 387   2                      {
 388   3                              cs_Line_State_Update = FALSE;
 389   3                                                                                                                      // Put Serial State Response on Fifo
 390   3      //                      FIFO_Write_code(FIFO_EP1, CS_SERIAL_STATE_NUM, serialStateResponse);
 391   3                              Fifo_Write(FIFO_EP1, CS_SERIAL_STATE_NUM, (BYTE *)serialStateResponse);
 392   3                              USB0DAT = cs_Line_State;                                        // Put UART state bitmap (LSB)
 393   3                              while(USB0ADR & 0x80);
 394   3                              USB0DAT = 0x00;                                                         //                                               (MSB)
 395   3                              while(USB0ADR & 0x80);
 396   3                              POLL_WRITE_BYTE(EINCSR1, rbInINPRDY);
 397   3                                                                                                                      // Set In Packet ready bit, indicating 
 398   3                                                                                                                      // fresh data on Fifo 1
 399   3                      }
 400   2              }
 401   1      }
 402          
 403          //-----------------------------------------------------------------------------
 404          // SDCC suport
 405          //-----------------------------------------------------------------------------
 406          #if defined SDCC
              #pragma restore
              #endif // SDCC
 409          
 410          //-----------------------------------------------------------------------------
 411          // Handle_In2
 412          //-----------------------------------------------------------------------------
 413          //      Handle IN EP2
 414          //      - Endpoint HALT - STALL
 415          //      - RX data stream
 416          //
 417          //      This routine is called from mainloop
 418          //-----------------------------------------------------------------------------
 419          
 420          void Handle_In2( void )
 421          {
 422   1              BYTE ControlReg;
 423   1              BYTE send_cnt, first_cnt, second_cnt;
 424   1              UINT pos;
 425   1              bit turnover;
 426   1      
 427   1              if (Ep_StatusIN2 == EP_IDLE)                                            // If endpoint is currently halted, 
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 8   

 428   1              {
 429   2                      EIE1 &= ~0x02;                                                                  // disable USB interrupt
 430   2      
 431   2                      POLL_WRITE_BYTE(INDEX, 2);                                              // Set index to endpoint 2 registers
 432   2                      POLL_READ_BYTE(EINCSR1, ControlReg);                    // Read contol register for EP
 433   2      
 434   2                                                                                                                      // RX buffer (UART --> host), USB side
 435   2                      if ( !(ControlReg & rbInINPRDY) && RXcount )    // FIFO is empty and must send?
 436   2                      {
 437   3                              if ( RXcount > EP2_PACKET_SIZE )                        // determine the bytes to send in this transaction
 438   3                                      send_cnt = EP2_PACKET_SIZE;
 439   3                              else
 440   3                                      send_cnt = (BYTE)RXcount;
 441   3      
 442   3                              pos = RXBUFSIZE - (RXRDPtr - RXBuffer);         // consider on wrap around of ring buffer
 443   3                              if ( send_cnt < pos )
 444   3                              {
 445   4                                      first_cnt = send_cnt;
 446   4                                      second_cnt = 0;
 447   4                                      turnover = FALSE;
 448   4                              }
 449   3                              else
 450   3                              {
 451   4                                      first_cnt = (BYTE)pos;
 452   4                                      second_cnt = send_cnt - first_cnt;
 453   4                                      turnover = TRUE;
 454   4                              }
 455   3      
 456   3                              FIFO_WRITE_FUNC( FIFO_EP2, first_cnt, RXRDPtr );        // send bytes to FIFO
 457   3                              if ( second_cnt != 0 )
 458   3                                      FIFO_WRITE_FUNC( FIFO_EP2, second_cnt, RXBuffer );
 459   3                              POLL_WRITE_BYTE(EINCSR1, rbInINPRDY);
 460   3      
 461   3                              if ( turnover )
 462   3                                      RXRDPtr = RXBuffer + second_cnt;
 463   3                              else
 464   3                                      RXRDPtr += send_cnt;
 465   3      
 466   3                              RXcount -= send_cnt;
 467   3                              RXReady = (RXcount != RXBUFSIZE);
 468   3                      }
 469   2      
 470   2                      EIE1 |= 0x02;                                                                   // enable USB interrupt
 471   2              }
 472   1      }
 473          
 474          //-----------------------------------------------------------------------------
 475          // Handle_Out2
 476          //-----------------------------------------------------------------------------
 477          //
 478          // Return Value : None
 479          // Parameters   : None
 480          //
 481          // Take the received packet from the host off the fifo and put it into
 482          // the Out_Packet array
 483          //
 484          //-----------------------------------------------------------------------------
 485          
 486          void Handle_Out2( void )
 487          {
 488   1              BYTE ControlReg;
 489   1              BYTE FIFO_Cnt, first_cnt, second_cnt;
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 9   

 490   1              UINT pos;
 491   1              bit turnover;
 492   1      
 493   1              if (Ep_StatusOUT2 == EP_IDLE)                                           // If endpoint is ready
 494   1              {
 495   2                      EIE1 &= ~0x02;                                                                  // disable USB interrupt
 496   2      
 497   2                      POLL_WRITE_BYTE(INDEX, 2);                                              // Set index to endpoint 2 registers
 498   2                      POLL_READ_BYTE(EOUTCSR1, ControlReg);
 499   2                                                                                                                      // TX buffer (host --> UART), USB side
 500   2                      if ( ControlReg & rbOutOPRDY )                                  // FIFO has data?
 501   2                      {
 502   3                              POLL_READ_BYTE(EOUTCNTL, FIFO_Cnt);                     // read out number of bytes on the FIFO
 503   3      
 504   3                              if ( (TXBUFSIZE - TXcount) >= FIFO_Cnt )        // if any room on the buffer to read out the FIFO
 505   3                              {
 506   4                                      pos = TXBUFSIZE - (TXWTPtr - TXBuffer); // consider on wrap around of ring buffer
 507   4                                      if ( FIFO_Cnt < pos )
 508   4                                      {
 509   5                                              first_cnt = FIFO_Cnt;
 510   5                                              second_cnt = 0;
 511   5                                              turnover = FALSE;
 512   5                                      }
 513   4                                      else
 514   4                                      {
 515   5                                              first_cnt = (BYTE)pos;
 516   5                                              second_cnt = FIFO_Cnt - first_cnt;
 517   5                                              turnover = TRUE;
 518   5                                      }
 519   4      
 520   4                                      FIFO_READ_FUNC( FIFO_EP2, first_cnt, TXWTPtr ); // read bytes from FIFO
 521   4                                      if ( second_cnt != 0 )
 522   4                                              FIFO_READ_FUNC( FIFO_EP2, second_cnt, TXBuffer );
 523   4                                      POLL_WRITE_BYTE(EOUTCSR1, 0);                   // Clear Out Packet ready bit
 524   4      
 525   4                                      if ( turnover )
 526   4                                              TXWTPtr = TXBuffer + second_cnt;
 527   4                                      else
 528   4                                              TXWTPtr += FIFO_Cnt;
 529   4      
 530   4                                      TXcount += FIFO_Cnt;
 531   4                                      TXReady = (TXcount != 0);
 532   4                              }
 533   3                      }
 534   2      
 535   2                      EIE1 |= 0x02;                                                                   // enable USB interrupt
 536   2              }
 537   1      }
 538          
 539          //-----------------------------------------------------------------------------
 540          // swap_endian_long
 541          //-----------------------------------------------------------------------------
 542          // swap endian for long varialbe
 543          //-----------------------------------------------------------------------------
 544          
 545          #if defined BIG_ENDIAN
 546          
 547          void swap_endian_long( ULONG idata *lptr )
 548          {
 549   1      /*
 550   1              BYTE tmp;
 551   1              BYTE idata * ptr = (BYTE idata *)lptr;
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 10  

 552   1      
 553   1              tmp = ptr[0];
 554   1              ptr[0] = ptr[3];
 555   1              ptr[3] = tmp;
 556   1              tmp = lptr[1];
 557   1              ptr[1] = ptr[2];
 558   1              ptr[2] = tmp;
 559   1      */
 560   1              BYTE tmp[4];
 561   1              BYTE idata * ptr = (BYTE idata *)lptr;
 562   1      
 563   1              tmp[3] = ptr[0];
 564   1              tmp[2] = ptr[1];
 565   1              tmp[1] = ptr[2];
 566   1              tmp[0] = ptr[3];
 567   1      
 568   1              ptr[0] = tmp[0];
 569   1              ptr[1] = tmp[1];
 570   1              ptr[2] = tmp[2];
 571   1              ptr[3] = tmp[3];
 572   1      }
 573          
 574          #endif // end of BIG_ENDIAN
 575          
 576          //-----------------------------------------------------------------------------
 577          // End Of File
 578          //-----------------------------------------------------------------------------
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 11  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Class_Request (BEGIN)
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
0000 7800        E     MOV     R0,#LOW Setup+05H
0002 E2                MOVX    A,@R0
0003 7002              JNZ     ?C0087
0005 18                DEC     R0
0006 E2                MOVX    A,@R0
0007         ?C0087:
0007 7029              JNZ     ?C0010
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 93
0009 7800        E     MOV     R0,#LOW Setup+01H
000B E2                MOVX    A,@R0
000C 14                DEC     A
000D 6014              JZ      ?C0004
000F 24E1              ADD     A,#0E1H
0011 6013              JZ      ?C0005
0013 14                DEC     A
0014 6013              JZ      ?C0006
0016 14                DEC     A
0017 6013              JZ      ?C0007
0019 14                DEC     A
001A 6013              JZ      ?C0008
001C 2423              ADD     A,#023H
001E 7012              JNZ     ?C0010
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 95
0020         ?C0003:
0020 020000      R     LJMP    CS_Send_Encapsulated_Command
                                           ; SOURCE LINE # 96
0023         ?C0004:
0023 020000      R     LJMP    CS_Get_Encapsulated_Command
                                           ; SOURCE LINE # 97
0026         ?C0005:
0026 020000      R     LJMP    CS_Set_Line_Coding
                                           ; SOURCE LINE # 98
0029         ?C0006:
0029 020000      R     LJMP    CS_Get_Line_Coding
                                           ; SOURCE LINE # 99
002C         ?C0007:
002C 020000      R     LJMP    CS_Set_ControlLine_State
                                           ; SOURCE LINE # 100
002F         ?C0008:
002F 120000      R     LCALL   CS_Send_Break
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 104
0032         ?C0010:
0032 22                RET     
             ; FUNCTION Class_Request (END)

             ; FUNCTION CS_Send_Encapsulated_Command (BEGIN)
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 120
0000 7800        E     MOV     R0,#LOW Setup
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 12  

0002 E2                MOVX    A,@R0
0003 B42132            CJNE    A,#021H,?C0012
0006 7800        E     MOV     R0,#LOW Setup+03H
0008 E2                MOVX    A,@R0
0009 7002              JNZ     ?C0088
000B 18                DEC     R0
000C E2                MOVX    A,@R0
000D         ?C0088:
000D 7029              JNZ     ?C0012
000F 7800        E     MOV     R0,#LOW Setup+06H
0011 E2                MOVX    A,@R0
0012 FE                MOV     R6,A
0013 08                INC     R0
0014 E2                MOVX    A,@R0
0015 FF                MOV     R7,A
0016 D3                SETB    C
0017 9407              SUBB    A,#07H
0019 EE                MOV     A,R6
001A 9400              SUBB    A,#00H
001C 501A              JNC     ?C0012
                                           ; SOURCE LINE # 123
                                           ; SOURCE LINE # 124
001E 7800        E     MOV     R0,#LOW Ep_Status0
0020 7403              MOV     A,#03H
0022 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 125
0023 7800        E     MOV     R0,#LOW DataPtr
0025 E4                CLR     A
0026 F2                MOVX    @R0,A
0027 08                INC     R0
0028 7400        R     MOV     A,#HIGH cs_temp_buffer
002A F2                MOVX    @R0,A
002B 08                INC     R0
002C 7400        R     MOV     A,#LOW cs_temp_buffer
002E F2                MOVX    @R0,A
                                           ; SOURCE LINE # 126
002F 7800        E     MOV     R0,#LOW DataSize
0031 EE                MOV     A,R6
0032 F2                MOVX    @R0,A
0033 08                INC     R0
0034 EF                MOV     A,R7
0035 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 127
0036 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
0038         ?C0012:
0038 22                RET     
             ; FUNCTION CS_Send_Encapsulated_Command (END)

             ; FUNCTION CS_Get_Encapsulated_Command (BEGIN)
                                           ; SOURCE LINE # 139
                                           ; SOURCE LINE # 140
                                           ; SOURCE LINE # 141
0000 7800        E     MOV     R0,#LOW Setup
0002 E2                MOVX    A,@R0
0003 B4A122            CJNE    A,#0A1H,?C0014
0006 7800        E     MOV     R0,#LOW Setup+03H
0008 E2                MOVX    A,@R0
0009 7002              JNZ     ?C0089
000B 18                DEC     R0
000C E2                MOVX    A,@R0
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 13  

000D         ?C0089:
000D 7019              JNZ     ?C0014
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 144
000F 7800        E     MOV     R0,#LOW Ep_Status0
0011 7402              MOV     A,#02H
0013 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 145
0014 7800        E     MOV     R0,#LOW DataPtr
0016 E4                CLR     A
0017 F2                MOVX    @R0,A
0018 08                INC     R0
0019 7400        R     MOV     A,#HIGH cs_temp_buffer
001B F2                MOVX    @R0,A
001C 08                INC     R0
001D 7400        R     MOV     A,#LOW cs_temp_buffer
001F F2                MOVX    @R0,A
                                           ; SOURCE LINE # 146
0020 E4                CLR     A
0021 7800        E     MOV     R0,#LOW DataSize
0023 F2                MOVX    @R0,A
0024 08                INC     R0
0025 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 147
0026 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 148
                                           ; SOURCE LINE # 149
0028         ?C0014:
0028 22                RET     
             ; FUNCTION CS_Get_Encapsulated_Command (END)

             ; FUNCTION CS_Set_Line_Coding (BEGIN)
                                           ; SOURCE LINE # 167
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
0000 7800        E     MOV     R0,#LOW Setup
0002 E2                MOVX    A,@R0
0003 B4212F            CJNE    A,#021H,?C0016
0006 7800        E     MOV     R0,#LOW Setup+03H
0008 E2                MOVX    A,@R0
0009 7002              JNZ     ?C0090
000B 18                DEC     R0
000C E2                MOVX    A,@R0
000D         ?C0090:
000D 7026              JNZ     ?C0016
000F 7800        E     MOV     R0,#LOW Setup+07H
0011 E2                MOVX    A,@R0
0012 6407              XRL     A,#07H
0014 7002              JNZ     ?C0091
0016 18                DEC     R0
0017 E2                MOVX    A,@R0
0018         ?C0091:
0018 701B              JNZ     ?C0016
                                           ; SOURCE LINE # 172
                                           ; SOURCE LINE # 173
001A 7800        E     MOV     R0,#LOW Ep_Status0
001C 7403              MOV     A,#03H
001E F2                MOVX    @R0,A
                                           ; SOURCE LINE # 174
001F 7800        E     MOV     R0,#LOW DataPtr
0021 E4                CLR     A
0022 F2                MOVX    @R0,A
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 14  

0023 08                INC     R0
0024 7400        R     MOV     A,#HIGH cs_temp_buffer
0026 F2                MOVX    @R0,A
0027 08                INC     R0
0028 7400        R     MOV     A,#LOW cs_temp_buffer
002A F2                MOVX    @R0,A
                                           ; SOURCE LINE # 175
002B 7800        E     MOV     R0,#LOW DataSize
002D E4                CLR     A
002E F2                MOVX    @R0,A
002F 08                INC     R0
0030 7407              MOV     A,#07H
0032 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 176
0033 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 178
0035         ?C0016:
0035 22                RET     
             ; FUNCTION CS_Set_Line_Coding (END)

             ; FUNCTION CS_Set_Line_Coding_Complete (BEGIN)
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 186
0000 7F00        R     MOV     R7,#LOW cs_temp_buffer
0002 120000      R     LCALL   _swap_endian_long
                                           ; SOURCE LINE # 190
0005 7F00        R     MOV     R7,#LOW cs_temp_buffer
0007 020000      E     LJMP    _Set_Line_Coding
             ; FUNCTION CS_Set_Line_Coding_Complete (END)

             ; FUNCTION CS_Get_Line_Coding (BEGIN)
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
0000 7800        E     MOV     R0,#LOW Setup
0002 E2                MOVX    A,@R0
0003 64A1              XRL     A,#0A1H
0005 705E              JNZ     ?C0022
0007 7800        E     MOV     R0,#LOW Setup+03H
0009 E2                MOVX    A,@R0
000A 7002              JNZ     ?C0092
000C 18                DEC     R0
000D E2                MOVX    A,@R0
000E         ?C0092:
000E 7055              JNZ     ?C0022
0010 7800        E     MOV     R0,#LOW Setup+07H
0012 E2                MOVX    A,@R0
0013 6407              XRL     A,#07H
0015 7002              JNZ     ?C0093
0017 18                DEC     R0
0018 E2                MOVX    A,@R0
0019         ?C0093:
0019 704A              JNZ     ?C0022
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 213
001B 7800        R     MOV     R0,#LOW dst
001D 7400        R     MOV     A,#LOW cs_temp_buffer
001F F2                MOVX    @R0,A
                                           ; SOURCE LINE # 214
0020 08                INC     R0
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 15  

0021 7400        E     MOV     A,#LOW uart_line_coding
0023 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 215
0024 7800        R     MOV     R0,#LOW cnt
0026 7407              MOV     A,#07H
0028 F2                MOVX    @R0,A
0029         ?C0019:
                                           ; SOURCE LINE # 216
0029 7800        R     MOV     R0,#LOW src
002B E2                MOVX    A,@R0
002C FF                MOV     R7,A
002D 04                INC     A
002E F2                MOVX    @R0,A
002F A807              MOV     R0,AR7
0031 E6                MOV     A,@R0
0032 FF                MOV     R7,A
0033 7800        R     MOV     R0,#LOW dst
0035 E2                MOVX    A,@R0
0036 FE                MOV     R6,A
0037 04                INC     A
0038 F2                MOVX    @R0,A
0039 A806              MOV     R0,AR6
003B A607              MOV     @R0,AR7
003D 7800        R     MOV     R0,#LOW cnt
003F E2                MOVX    A,@R0
0040 14                DEC     A
0041 F2                MOVX    @R0,A
0042 E2                MOVX    A,@R0
0043 70E4              JNZ     ?C0019
0045         ?C0020:
                                           ; SOURCE LINE # 218
0045 7F00        R     MOV     R7,#LOW cs_temp_buffer
0047 120000      R     LCALL   _swap_endian_long
                                           ; SOURCE LINE # 220
004A 7800        E     MOV     R0,#LOW DataPtr
004C E4                CLR     A
004D F2                MOVX    @R0,A
004E 08                INC     R0
004F 7400        R     MOV     A,#HIGH cs_temp_buffer
0051 F2                MOVX    @R0,A
0052 08                INC     R0
0053 7400        R     MOV     A,#LOW cs_temp_buffer
0055 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 225
0056 7800        E     MOV     R0,#LOW Ep_Status0
0058 7402              MOV     A,#02H
005A F2                MOVX    @R0,A
                                           ; SOURCE LINE # 226
005B 7800        E     MOV     R0,#LOW DataSize
005D E4                CLR     A
005E F2                MOVX    @R0,A
005F 08                INC     R0
0060 7407              MOV     A,#07H
0062 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 227
0063 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 229
0065         ?C0022:
0065 22                RET     
             ; FUNCTION CS_Get_Line_Coding (END)

C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 16  

             ; FUNCTION CS_Set_ControlLine_State (BEGIN)
                                           ; SOURCE LINE # 242
                                           ; SOURCE LINE # 243
                                           ; SOURCE LINE # 244
0000 7800        E     MOV     R0,#LOW Setup
0002 E2                MOVX    A,@R0
0003 B42114            CJNE    A,#021H,?C0024
0006 7800        E     MOV     R0,#LOW Setup+07H
0008 E2                MOVX    A,@R0
0009 7002              JNZ     ?C0094
000B 18                DEC     R0
000C E2                MOVX    A,@R0
000D         ?C0094:
000D 700B              JNZ     ?C0024
                                           ; SOURCE LINE # 246
                                           ; SOURCE LINE # 247
000F 7800        E     MOV     R0,#LOW Setup+03H
0011 E2                MOVX    A,@R0
0012 5403              ANL     A,#03H
0014 FF                MOV     R7,A
0015 120000      E     LCALL   _Set_Line_State
                                           ; SOURCE LINE # 248
0018 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 250
001A         ?C0024:
001A 22                RET     
             ; FUNCTION CS_Set_ControlLine_State (END)

             ; FUNCTION CS_Send_Break (BEGIN)
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
0000 7800        E     MOV     R0,#LOW Setup
0002 E2                MOVX    A,@R0
0003 B42115            CJNE    A,#021H,?C0026
0006 7800        E     MOV     R0,#LOW Setup+07H
0008 E2                MOVX    A,@R0
0009 7002              JNZ     ?C0095
000B 18                DEC     R0
000C E2                MOVX    A,@R0
000D         ?C0095:
000D 700C              JNZ     ?C0026
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
000F 7800        E     MOV     R0,#LOW Setup+02H
0011 E2                MOVX    A,@R0
0012 FE                MOV     R6,A
0013 08                INC     R0
0014 E2                MOVX    A,@R0
0015 FF                MOV     R7,A
0016 120000      E     LCALL   _Send_Break
                                           ; SOURCE LINE # 269
0019 D200        E     SETB    setup_handled
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 271
001B         ?C0026:
001B 22                RET     
             ; FUNCTION CS_Send_Break (END)

             ; FUNCTION Vendor_Request (BEGIN)
                                           ; SOURCE LINE # 297
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 17  

                                           ; SOURCE LINE # 298
                                           ; SOURCE LINE # 299
0000 22                RET     
             ; FUNCTION Vendor_Request (END)

             ; FUNCTION Handle_In1 (BEGIN)
                                           ; SOURCE LINE # 376
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 380
0000 20004D      E     JB      Ep_Status1,?C0042
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0003         ?C0029:
0003 E596              MOV     A,USB0ADR
0005 20E7FB            JB      ACC.7,?C0029
0008         ?C0030:
0008 75960E            MOV     USB0ADR,#0EH
000B 759701            MOV     USB0DAT,#01H
                                           ; SOURCE LINE # 383
000E         ?C0031:
000E E596              MOV     A,USB0ADR
0010 20E7FB            JB      ACC.7,?C0031
0013         ?C0032:
0013 759691            MOV     USB0ADR,#091H
0016         ?C0033:
0016 E596              MOV     A,USB0ADR
0018 20E7FB            JB      ACC.7,?C0033
001B         ?C0034:
;---- Variable 'ControlReg' assigned to Register 'R7' ----
001B AF97              MOV     R7,USB0DAT
                                           ; SOURCE LINE # 385
001D EF                MOV     A,R7
001E 20E02F            JB      ACC.0,?C0042
0021 30002C      R     JNB     cs_Line_State_Update,?C0042
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
0024 C200        R     CLR     cs_Line_State_Update
                                           ; SOURCE LINE # 391
0026 7BFF              MOV     R3,#0FFH
0028 7A00        R     MOV     R2,#HIGH serialStateResponse
002A 7900        R     MOV     R1,#LOW serialStateResponse
002C 7D08              MOV     R5,#08H
002E 7F21              MOV     R7,#021H
0030 120000      E     LCALL   _Fifo_Write
                                           ; SOURCE LINE # 392
0033 7800        R     MOV     R0,#LOW cs_Line_State
0035 E2                MOVX    A,@R0
0036 F597              MOV     USB0DAT,A
0038         ?C0036:
                                           ; SOURCE LINE # 393
0038 E596              MOV     A,USB0ADR
003A 20E7FB            JB      ACC.7,?C0036
003D         ?C0037:
                                           ; SOURCE LINE # 394
003D E4                CLR     A
003E F597              MOV     USB0DAT,A
0040         ?C0038:
                                           ; SOURCE LINE # 395
0040 E596              MOV     A,USB0ADR
0042 20E7FB            JB      ACC.7,?C0038
0045         ?C0039:
                                           ; SOURCE LINE # 396
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 18  

0045         ?C0040:
0045 E596              MOV     A,USB0ADR
0047 20E7FB            JB      ACC.7,?C0040
004A         ?C0041:
004A 759611            MOV     USB0ADR,#011H
004D 759701            MOV     USB0DAT,#01H
                                           ; SOURCE LINE # 399
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 401
0050         ?C0042:
0050 22                RET     
             ; FUNCTION Handle_In1 (END)

             ; FUNCTION Handle_In2 (BEGIN)
                                           ; SOURCE LINE # 420
                                           ; SOURCE LINE # 421
                                           ; SOURCE LINE # 427
0000 300003      E     JNB     Ep_StatusIN2,$ + 6H
0003 020000      R     LJMP    ?C0062
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
0006 53E6FD            ANL     EIE1,#0FDH
                                           ; SOURCE LINE # 431
0009         ?C0044:
0009 E596              MOV     A,USB0ADR
000B 20E7FB            JB      ACC.7,?C0044
000E         ?C0045:
000E 75960E            MOV     USB0ADR,#0EH
0011 759702            MOV     USB0DAT,#02H
                                           ; SOURCE LINE # 432
0014         ?C0046:
0014 E596              MOV     A,USB0ADR
0016 20E7FB            JB      ACC.7,?C0046
0019         ?C0047:
0019 759691            MOV     USB0ADR,#091H
001C         ?C0048:
001C E596              MOV     A,USB0ADR
001E 20E7FB            JB      ACC.7,?C0048
0021         ?C0049:
;---- Variable 'ControlReg' assigned to Register 'R7' ----
0021 AF97              MOV     R7,USB0DAT
                                           ; SOURCE LINE # 435
0023 EF                MOV     A,R7
0024 30E003            JNB     ACC.0,$ + 6H
0027 020000      R     LJMP    ?C0050
002A 7800        E     MOV     R0,#LOW RXcount
002C E2                MOVX    A,@R0
002D FE                MOV     R6,A
002E 08                INC     R0
002F E2                MOVX    A,@R0
0030 FF                MOV     R7,A
0031 4E                ORL     A,R6
0032 7003              JNZ     $ + 5H
0034 020000      R     LJMP    ?C0050
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
0037 D3                SETB    C
0038 EF                MOV     A,R7
0039 9440              SUBB    A,#040H
003B EE                MOV     A,R6
003C 9400              SUBB    A,#00H
003E 7800        R     MOV     R0,#LOW send_cnt
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 19  

0040 4005              JC      ?C0051
                                           ; SOURCE LINE # 438
0042 7440              MOV     A,#040H
0044 F2                MOVX    @R0,A
0045 8002              SJMP    ?C0052
0047         ?C0051:
                                           ; SOURCE LINE # 440
0047 EF                MOV     A,R7
0048 F2                MOVX    @R0,A
0049         ?C0052:
                                           ; SOURCE LINE # 442
0049 7800        E     MOV     R0,#LOW RXRDPtr
004B E2                MOVX    A,@R0
004C FE                MOV     R6,A
004D 08                INC     R0
004E E2                MOVX    A,@R0
004F C3                CLR     C
0050 9400        E     SUBB    A,#LOW RXBuffer
0052 FF                MOV     R7,A
0053 EE                MOV     A,R6
0054 9400        E     SUBB    A,#HIGH RXBuffer
0056 FE                MOV     R6,A
0057 C3                CLR     C
0058 7450              MOV     A,#050H
005A 9F                SUBB    A,R7
005B FF                MOV     R7,A
005C E4                CLR     A
005D 9E                SUBB    A,R6
005E FE                MOV     R6,A
;---- Variable 'pos' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 443
005F 7800        R     MOV     R0,#LOW send_cnt
0061 E2                MOVX    A,@R0
0062 FD                MOV     R5,A
0063 C3                CLR     C
0064 9F                SUBB    A,R7
0065 E4                CLR     A
0066 9E                SUBB    A,R6
0067 500A              JNC     ?C0053
                                           ; SOURCE LINE # 444
                                           ; SOURCE LINE # 445
0069 08                INC     R0
006A ED                MOV     A,R5
006B F2                MOVX    @R0,A
                                           ; SOURCE LINE # 446
006C E4                CLR     A
006D 08                INC     R0
006E F2                MOVX    @R0,A
                                           ; SOURCE LINE # 447
006F C200        R     CLR     turnover
                                           ; SOURCE LINE # 448
0071 800D              SJMP    ?C0054
0073         ?C0053:
                                           ; SOURCE LINE # 450
                                           ; SOURCE LINE # 451
0073 7800        R     MOV     R0,#LOW first_cnt
0075 EF                MOV     A,R7
0076 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 452
0077 18                DEC     R0
0078 E2                MOVX    A,@R0
0079 C3                CLR     C
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 20  

007A 9F                SUBB    A,R7
007B 7800        R     MOV     R0,#LOW second_cnt
007D F2                MOVX    @R0,A
                                           ; SOURCE LINE # 453
007E D200        R     SETB    turnover
                                           ; SOURCE LINE # 454
0080         ?C0054:
                                           ; SOURCE LINE # 456
0080 7800        R     MOV     R0,#LOW first_cnt
0082 E2                MOVX    A,@R0
0083 FD                MOV     R5,A
0084 7800        E     MOV     R0,#LOW RXRDPtr
0086 E2                MOVX    A,@R0
0087 FA                MOV     R2,A
0088 08                INC     R0
0089 E2                MOVX    A,@R0
008A FB                MOV     R3,A
008B 7F22              MOV     R7,#022H
008D 120000      E     LCALL   _FIFO_Write_xdata
                                           ; SOURCE LINE # 457
0090 7800        R     MOV     R0,#LOW second_cnt
0092 E2                MOVX    A,@R0
0093 FD                MOV     R5,A
0094 6009              JZ      ?C0056
                                           ; SOURCE LINE # 458
0096 7A00        E     MOV     R2,#HIGH RXBuffer
0098 7B00        E     MOV     R3,#LOW RXBuffer
009A 7F22              MOV     R7,#022H
009C 120000      E     LCALL   _FIFO_Write_xdata
                                           ; SOURCE LINE # 459
009F         ?C0056:
009F E596              MOV     A,USB0ADR
00A1 20E7FB            JB      ACC.7,?C0056
00A4         ?C0057:
00A4 759611            MOV     USB0ADR,#011H
00A7 759701            MOV     USB0DAT,#01H
                                           ; SOURCE LINE # 461
00AA 300014      R     JNB     turnover,?C0058
                                           ; SOURCE LINE # 462
00AD 7800        R     MOV     R0,#LOW second_cnt
00AF E2                MOVX    A,@R0
00B0 2400        E     ADD     A,#LOW RXBuffer
00B2 F582              MOV     DPL,A
00B4 E4                CLR     A
00B5 3400        E     ADDC    A,#HIGH RXBuffer
00B7 AF82              MOV     R7,DPL
00B9 7800        E     MOV     R0,#LOW RXRDPtr
00BB F2                MOVX    @R0,A
00BC 08                INC     R0
00BD EF                MOV     A,R7
00BE F2                MOVX    @R0,A
00BF 800E              SJMP    ?C0059
00C1         ?C0058:
                                           ; SOURCE LINE # 464
00C1 7800        R     MOV     R0,#LOW send_cnt
00C3 E2                MOVX    A,@R0
00C4 FF                MOV     R7,A
00C5 7800        E     MOV     R0,#LOW RXRDPtr+01H
00C7 E2                MOVX    A,@R0
00C8 2F                ADD     A,R7
00C9 F2                MOVX    @R0,A
00CA 18                DEC     R0
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 21  

00CB E2                MOVX    A,@R0
00CC 3400              ADDC    A,#00H
00CE F2                MOVX    @R0,A
00CF         ?C0059:
                                           ; SOURCE LINE # 466
00CF 7800        R     MOV     R0,#LOW send_cnt
00D1 E2                MOVX    A,@R0
00D2 FF                MOV     R7,A
00D3 C3                CLR     C
00D4 7800        E     MOV     R0,#LOW RXcount+01H
00D6 E2                MOVX    A,@R0
00D7 9F                SUBB    A,R7
00D8 FF                MOV     R7,A
00D9 18                DEC     R0
00DA E2                MOVX    A,@R0
00DB 9400              SUBB    A,#00H
00DD FE                MOV     R6,A
00DE F2                MOVX    @R0,A
00DF 08                INC     R0
00E0 EF                MOV     A,R7
00E1 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 467
00E2 6450              XRL     A,#050H
00E4 4E                ORL     A,R6
00E5 6003              JZ      ?C0060
00E7 D3                SETB    C
00E8 8001              SJMP    ?C0061
00EA         ?C0060:
00EA C3                CLR     C
00EB         ?C0061:
00EB 9200        E     MOV     RXReady,C
                                           ; SOURCE LINE # 468
00ED         ?C0050:
                                           ; SOURCE LINE # 470
00ED 43E602            ORL     EIE1,#02H
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
00F0         ?C0062:
00F0 22                RET     
             ; FUNCTION Handle_In2 (END)

             ; FUNCTION Handle_Out2 (BEGIN)
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
                                           ; SOURCE LINE # 493
0000 300003      E     JNB     Ep_StatusOUT2,$ + 6H
0003 020000      R     LJMP    ?C0085
                                           ; SOURCE LINE # 494
                                           ; SOURCE LINE # 495
0006 53E6FD            ANL     EIE1,#0FDH
                                           ; SOURCE LINE # 497
0009         ?C0064:
0009 E596              MOV     A,USB0ADR
000B 20E7FB            JB      ACC.7,?C0064
000E         ?C0065:
000E 75960E            MOV     USB0ADR,#0EH
0011 759702            MOV     USB0DAT,#02H
                                           ; SOURCE LINE # 498
0014         ?C0066:
0014 E596              MOV     A,USB0ADR
0016 20E7FB            JB      ACC.7,?C0066
0019         ?C0067:
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 22  

0019 759694            MOV     USB0ADR,#094H
001C         ?C0068:
001C E596              MOV     A,USB0ADR
001E 20E7FB            JB      ACC.7,?C0068
0021         ?C0069:
;---- Variable 'ControlReg' assigned to Register 'R7' ----
0021 AF97              MOV     R7,USB0DAT
                                           ; SOURCE LINE # 500
0023 EF                MOV     A,R7
0024 20E003            JB      ACC.0,$ + 6H
0027 020000      R     LJMP    ?C0070
                                           ; SOURCE LINE # 501
                                           ; SOURCE LINE # 502
002A         ?C0071:
002A E596              MOV     A,USB0ADR
002C 20E7FB            JB      ACC.7,?C0071
002F         ?C0072:
002F 759696            MOV     USB0ADR,#096H
0032         ?C0073:
0032 E596              MOV     A,USB0ADR
0034 20E7FB            JB      ACC.7,?C0073
0037         ?C0074:
0037 7800        R     MOV     R0,#LOW FIFO_Cnt
0039 E597              MOV     A,USB0DAT
003B F2                MOVX    @R0,A
                                           ; SOURCE LINE # 504
003C 7800        E     MOV     R0,#LOW TXcount
003E E2                MOVX    A,@R0
003F FE                MOV     R6,A
0040 08                INC     R0
0041 E2                MOVX    A,@R0
0042 FF                MOV     R7,A
0043 C3                CLR     C
0044 7450              MOV     A,#050H
0046 9F                SUBB    A,R7
0047 FF                MOV     R7,A
0048 E4                CLR     A
0049 9E                SUBB    A,R6
004A FE                MOV     R6,A
004B 7800        R     MOV     R0,#LOW FIFO_Cnt
004D E2                MOVX    A,@R0
004E FD                MOV     R5,A
004F C3                CLR     C
0050 EF                MOV     A,R7
0051 9D                SUBB    A,R5
0052 EE                MOV     A,R6
0053 9400              SUBB    A,#00H
0055 5003              JNC     $ + 5H
0057 020000      R     LJMP    ?C0070
                                           ; SOURCE LINE # 505
                                           ; SOURCE LINE # 506
005A 7800        E     MOV     R0,#LOW TXWTPtr
005C E2                MOVX    A,@R0
005D FE                MOV     R6,A
005E 08                INC     R0
005F E2                MOVX    A,@R0
0060 9400        E     SUBB    A,#LOW TXBuffer
0062 FF                MOV     R7,A
0063 EE                MOV     A,R6
0064 9400        E     SUBB    A,#HIGH TXBuffer
0066 FE                MOV     R6,A
0067 C3                CLR     C
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 23  

0068 7450              MOV     A,#050H
006A 9F                SUBB    A,R7
006B FF                MOV     R7,A
006C E4                CLR     A
006D 9E                SUBB    A,R6
006E FE                MOV     R6,A
;---- Variable 'pos' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 507
006F 7800        R     MOV     R0,#LOW FIFO_Cnt
0071 E2                MOVX    A,@R0
0072 FD                MOV     R5,A
0073 C3                CLR     C
0074 9F                SUBB    A,R7
0075 E4                CLR     A
0076 9E                SUBB    A,R6
0077 500A              JNC     ?C0076
                                           ; SOURCE LINE # 508
                                           ; SOURCE LINE # 509
0079 08                INC     R0
007A ED                MOV     A,R5
007B F2                MOVX    @R0,A
                                           ; SOURCE LINE # 510
007C E4                CLR     A
007D 08                INC     R0
007E F2                MOVX    @R0,A
                                           ; SOURCE LINE # 511
007F C200        R     CLR     turnover
                                           ; SOURCE LINE # 512
0081 800D              SJMP    ?C0077
0083         ?C0076:
                                           ; SOURCE LINE # 514
                                           ; SOURCE LINE # 515
0083 7800        R     MOV     R0,#LOW first_cnt
0085 EF                MOV     A,R7
0086 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 516
0087 18                DEC     R0
0088 E2                MOVX    A,@R0
0089 C3                CLR     C
008A 9F                SUBB    A,R7
008B 7800        R     MOV     R0,#LOW second_cnt
008D F2                MOVX    @R0,A
                                           ; SOURCE LINE # 517
008E D200        R     SETB    turnover
                                           ; SOURCE LINE # 518
0090         ?C0077:
                                           ; SOURCE LINE # 520
0090 7800        R     MOV     R0,#LOW first_cnt
0092 E2                MOVX    A,@R0
0093 FD                MOV     R5,A
0094 7800        E     MOV     R0,#LOW TXWTPtr
0096 E2                MOVX    A,@R0
0097 FA                MOV     R2,A
0098 08                INC     R0
0099 E2                MOVX    A,@R0
009A FB                MOV     R3,A
009B 7F22              MOV     R7,#022H
009D 120000      E     LCALL   _FIFO_Read_xdata
                                           ; SOURCE LINE # 521
00A0 7800        R     MOV     R0,#LOW second_cnt
00A2 E2                MOVX    A,@R0
00A3 FD                MOV     R5,A
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 24  

00A4 6009              JZ      ?C0079
                                           ; SOURCE LINE # 522
00A6 7A00        E     MOV     R2,#HIGH TXBuffer
00A8 7B00        E     MOV     R3,#LOW TXBuffer
00AA 7F22              MOV     R7,#022H
00AC 120000      E     LCALL   _FIFO_Read_xdata
                                           ; SOURCE LINE # 523
00AF         ?C0079:
00AF E596              MOV     A,USB0ADR
00B1 20E7FB            JB      ACC.7,?C0079
00B4         ?C0080:
00B4 759614            MOV     USB0ADR,#014H
00B7 E4                CLR     A
00B8 F597              MOV     USB0DAT,A
                                           ; SOURCE LINE # 525
00BA 300014      R     JNB     turnover,?C0081
                                           ; SOURCE LINE # 526
00BD 7800        R     MOV     R0,#LOW second_cnt
00BF E2                MOVX    A,@R0
00C0 2400        E     ADD     A,#LOW TXBuffer
00C2 F582              MOV     DPL,A
00C4 E4                CLR     A
00C5 3400        E     ADDC    A,#HIGH TXBuffer
00C7 AF82              MOV     R7,DPL
00C9 7800        E     MOV     R0,#LOW TXWTPtr
00CB F2                MOVX    @R0,A
00CC 08                INC     R0
00CD EF                MOV     A,R7
00CE F2                MOVX    @R0,A
00CF 800E              SJMP    ?C0082
00D1         ?C0081:
                                           ; SOURCE LINE # 528
00D1 7800        R     MOV     R0,#LOW FIFO_Cnt
00D3 E2                MOVX    A,@R0
00D4 FF                MOV     R7,A
00D5 7800        E     MOV     R0,#LOW TXWTPtr+01H
00D7 E2                MOVX    A,@R0
00D8 2F                ADD     A,R7
00D9 F2                MOVX    @R0,A
00DA 18                DEC     R0
00DB E2                MOVX    A,@R0
00DC 3400              ADDC    A,#00H
00DE F2                MOVX    @R0,A
00DF         ?C0082:
                                           ; SOURCE LINE # 530
00DF 7800        R     MOV     R0,#LOW FIFO_Cnt
00E1 E2                MOVX    A,@R0
00E2 FF                MOV     R7,A
00E3 7800        E     MOV     R0,#LOW TXcount+01H
00E5 E2                MOVX    A,@R0
00E6 2F                ADD     A,R7
00E7 F2                MOVX    @R0,A
00E8 18                DEC     R0
00E9 E2                MOVX    A,@R0
00EA 3400              ADDC    A,#00H
00EC F2                MOVX    @R0,A
                                           ; SOURCE LINE # 531
00ED 08                INC     R0
00EE E2                MOVX    A,@R0
00EF 7002              JNZ     ?C0096
00F1 18                DEC     R0
00F2 E2                MOVX    A,@R0
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 25  

00F3         ?C0096:
00F3 6003              JZ      ?C0083
00F5 D3                SETB    C
00F6 8001              SJMP    ?C0084
00F8         ?C0083:
00F8 C3                CLR     C
00F9         ?C0084:
00F9 9200        E     MOV     TXReady,C
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 533
00FB         ?C0070:
                                           ; SOURCE LINE # 535
00FB 43E602            ORL     EIE1,#02H
                                           ; SOURCE LINE # 536
                                           ; SOURCE LINE # 537
00FE         ?C0085:
00FE 22                RET     
             ; FUNCTION Handle_Out2 (END)

             ; FUNCTION _swap_endian_long (BEGIN)
                                           ; SOURCE LINE # 547
;---- Variable 'lptr' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 561
;---- Variable 'ptr' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 563
0000 A807              MOV     R0,AR7
0002 E6                MOV     A,@R0
0003 7800        R     MOV     R0,#LOW tmp+03H
0005 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 564
0006 EF                MOV     A,R7
0007 04                INC     A
0008 F8                MOV     R0,A
0009 E6                MOV     A,@R0
000A 7800        R     MOV     R0,#LOW tmp+02H
000C F2                MOVX    @R0,A
                                           ; SOURCE LINE # 565
000D EF                MOV     A,R7
000E 2402              ADD     A,#02H
0010 F8                MOV     R0,A
0011 E6                MOV     A,@R0
0012 7800        R     MOV     R0,#LOW tmp+01H
0014 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 566
0015 EF                MOV     A,R7
0016 2403              ADD     A,#03H
0018 F8                MOV     R0,A
0019 E6                MOV     A,@R0
001A 7800        R     MOV     R0,#LOW tmp
001C F2                MOVX    @R0,A
                                           ; SOURCE LINE # 568
001D A807              MOV     R0,AR7
001F F6                MOV     @R0,A
                                           ; SOURCE LINE # 569
0020 7800        R     MOV     R0,#LOW tmp+01H
0022 E2                MOVX    A,@R0
0023 FE                MOV     R6,A
0024 EF                MOV     A,R7
0025 04                INC     A
0026 F8                MOV     R0,A
0027 A606              MOV     @R0,AR6
C51 COMPILER V9.50a   USB_CLASS_REQUESTS                                                   04/03/2023 15:54:12 PAGE 26  

                                           ; SOURCE LINE # 570
0029 7800        R     MOV     R0,#LOW tmp+02H
002B E2                MOVX    A,@R0
002C FE                MOV     R6,A
002D EF                MOV     A,R7
002E 2402              ADD     A,#02H
0030 F8                MOV     R0,A
0031 A606              MOV     @R0,AR6
                                           ; SOURCE LINE # 571
0033 7800        R     MOV     R0,#LOW tmp+03H
0035 E2                MOVX    A,@R0
0036 FE                MOV     R6,A
0037 EF                MOV     A,R7
0038 2403              ADD     A,#03H
003A F8                MOV     R0,A
003B A606              MOV     @R0,AR6
                                           ; SOURCE LINE # 572
003D 22                RET     
             ; FUNCTION _swap_endian_long (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1010    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      1      13
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      7    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
